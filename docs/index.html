<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Parallel PopGen Package: Getting Started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Parallel PopGen Package
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Getting Started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#API">API Overview</a><ul><li class="level2"><a href="#Tips">Tips</a></li>
<li class="level2"><a href="#Troubleshooting">Troubleshooting</a></li>
<li class="level2"><a href="#δaδi">δaδi-to-GOFish Parameter Conversion</a><ul><li class="level3"><a href="#Inbreeding">Inbreeding</a></li>
<li class="level3"><a href="#Dominance">Dominance</a></li>
<li class="level3"><a href="#Selection">Selection</a></li>
<li class="level3"><a href="#Demography">Demography</a></li>
<li class="level3"><a href="#Migration">Migration</a></li>
<li class="level3"><a href="#generations">Number of Generations</a></li>
<li class="level3"><a href="#mut_sites">Mutation rate</a></li>
<li class="level3"><a href="#numSites">Number of Sites</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Important links:<br />
 </p><ul>
<li><a class="el" href="md__r_e_a_d_m_e.html">Parallel PopGen Package v0.3 README</a> for installation and compilation instructions and change-log </li>
<li><a href="https://github.com/DL42/ParallelPopGen/issues">Bug Reporting, Feature Request, To Do, and Discussion</a> </li>
<li><a href="https://github.com/DL42/ParallelPopGen/releases">Download Stable Releases</a> </li>
<li><a href="https://github.com/DL42/ParallelPopGen">GitHub repository for latest changes</a></li>
</ul>
<h1><a class="anchor" id="API"></a>
API Overview</h1>
<p>Welcome to the manual for the Parallel PopGen Package (3P)! This is a library of CUDA C/C++ APIs for performing population genetics simulations and analyses on the GPU. Using the 3P APIs, complex, powerful, and fast simulations and analyses can be written in otherwise standard C++ - requiring no knowledge of parallel/GPU programming from the end-user. Below is a brief description of the information found in this manual, organized in the tabs above: </p><ul>
<li><a href="namespaces.html">Namespaces</a> provides all functions and classes related to an API (e.g. <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a>). </li>
<li><a href="modules.html">Modules</a> page organizes the <a class="el" href="namespace_sim___model.html" title="Namespace of functions for controlling GO_Fish simulations. ">Sim_Model</a> namespace into groups of functions (e.g. <a class="el" href="group__selection.html">Simulation Models: Selection Group</a>) - each module describes the parameters and output of the function group and how to write custom simulation functions. </li>
<li><a href="files.html">Files</a> shows the file hierarchy, the functions and classes in each file, and the detailed description of each header file provides information on how to include the files for a project. </li>
<li><a href="annotated.html">Classes</a> shows all classes and structs organized by namespace. </li>
<li><a href="examples.html">Examples</a> provides code examples and custom makefiles found in the examples/ folder.</li>
</ul>
<p>3P currently contains 3 APIs, each in its own namespace: </p><ul>
<li><a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a>: Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures. </li>
<li><a class="el" href="namespace_sim___model.html" title="Namespace of functions for controlling GO_Fish simulations. ">Sim_Model</a>: Namespace of functions for controlling <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> simulations. <a class="el" href="namespace_sim___model.html" title="Namespace of functions for controlling GO_Fish simulations. ">Sim_Model</a> is optional as the user is free to write their own population genetics and simulation control functions following the rules laid out in each function group's <a href="modules.html">Module</a>. </li>
<li><a class="el" href="namespace_spectrum.html" title="Namespace for site frequency spectrum data structure and functions. (in prototype-phase) ...">Spectrum</a>: Namespace for site frequency spectrum data structure and functions. (in prototype-phase)</li>
</ul>
<p>The relevant header files are in the folder include/ </p><ul>
<li><a class="el" href="go__fish_8cuh.html" title="GO Fish Simulation API (contains namespaces GO_Fish and Sim_Model) ">go_fish.cuh</a>: GO Fish Simulation API (contains namespaces <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> and <a class="el" href="namespace_sim___model.html" title="Namespace of functions for controlling GO_Fish simulations. ">Sim_Model</a>) </li>
<li><a class="el" href="go__fish__data__struct_8h.html" title="Subset of go_fish.cuh (the GO_Fish data structures) ">go_fish_data_struct.h</a>: Subset of <a class="el" href="go__fish_8cuh.html" title="GO Fish Simulation API (contains namespaces GO_Fish and Sim_Model) ">go_fish.cuh</a> (the <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> data structures) </li>
<li><a class="el" href="spectrum_8h.html" title="proto-API for building site frequency spectra (contains the titular namespace Spectrum) ...">spectrum.h</a>: proto-API for building site frequency spectra (contains the titular namespace <a class="el" href="namespace_spectrum.html" title="Namespace for site frequency spectrum data structure and functions. (in prototype-phase) ...">Spectrum</a>)</li>
</ul>
<p>The implementations of these header files are in the source/ folder. All outside libraries used in the Parallel PopGen Package (beyond standard CUDA and C/C++ libs) are stored in the folder outside_libraries/ and are automatically included. The examples in the examples/ folder show how to compile a project which using a 3P API (also covered in <a class="el" href="md__r_e_a_d_m_e.html">Parallel PopGen Package v0.3 README</a>).</p>
<h2><a class="anchor" id="Tips"></a>
Tips</h2>
<p>For faster <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> simulations: </p><ul>
<li>Play around with <a class="el" href="struct_g_o___fish_1_1allele__trajectories_1_1sim__constants.html#a3a5406282cfa4db45a72213bd5e50e65">GO_Fish::allele_trajectories::sim_constants::compact_interval</a>.<ul>
<li>The variable compact_interval determines when to trow away mutations that have been lost or fixed by all populations in the simulation. Raise it to do it less often, lower it for more often. Optimal compact intervals can only be determined heuristically - larger simulations (with more mutations) need to be compacted more often than smaller simulations, while faster GPUs with more cores need to compact less often than slower ones with fewer cores. <br />
<br />
 </li>
</ul>
</li>
<li>When simulating full allele_trajectories, turn off compact_interval.<ul>
<li>To record the frequency of every mutation for every generation, pass <a class="el" href="struct_sim___model_1_1bool__on.html" title="functor: turns sampling and preserving on (for every generation except the final one which is always ...">Sim_Model::bool_on</a> to <a class="el" href="namespace_g_o___fish.html#a7e11d273a799f6ddbda24e3115a49083" title="runs a single-locus Wright-Fisher simulation specified by the given simulation functions and sim_cons...">GO_Fish::run_sim</a>'s parameter Functor_timesample take_sample and set <a class="el" href="struct_g_o___fish_1_1allele__trajectories_1_1sim__constants.html#a3a5406282cfa4db45a72213bd5e50e65" title="how often to compact the simulation and remove fixed or lost mutations ">GO_Fish::allele_trajectories::sim_constants::compact_interval</a> <code>= 0</code>. <br />
<br />
 </li>
</ul>
</li>
<li>When simulating for the purposes of generating SFS (and other applications), scale the simulation by a reference population size to simulate fewer generations/smaller populations.<ul>
<li>See <a class="el" href="_example2-_da_di-example.html">Example2-DaDi</a> and <a class="el" href="index.html#δaδi">δaδi-to-GOFish Parameter Conversion</a> for an examples and general how-to. <br />
<br />
 </li>
</ul>
</li>
<li><a class="el" href="namespace_g_o___fish.html#a7e11d273a799f6ddbda24e3115a49083" title="runs a single-locus Wright-Fisher simulation specified by the given simulation functions and sim_cons...">GO_Fish::run_sim</a> has an important <b>Pro tip</b> regarding input template functions.</li>
</ul>
<p>(<b>Advanced users</b>) In implementation file <a class="el" href="shared_8cuh_source.html">shared.cuh</a>, there are several variables that can be tuned: </p><ul>
<li><code>typedef r123::Philox4x32_R&lt;10&gt; P;</code>: &lt;10&gt; can be set as low as &lt;8&gt; for extra-speed.<ul>
<li>Philox is the random number generator for <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a>. The 10 refers to the number of bijections it performs to generate a new random number. The authors of Philox state that 8 is the lowest safe limit, but 10 is recommended for maximum speed. Current default setting in <a class="el" href="shared_8cuh_source.html">shared.cuh</a> is 10. <br />
<br />
 </li>
</ul>
</li>
<li><code>#define RNG_MEAN_BOUNDARY_NORM 6</code>: <code>RNG_MEAN_BOUNDARY_NORM</code> can be set between 1-33<ul>
<li>recommended setting is between 6-15, current default is 6. If the expected (mean) result of the RNG for the distribution is greater than RNG_MEAN_BOUNDARY_NORM, the normal approximation is used; less than RNG_MEAN_BOUNDARY_NORM, the poisson/ binomial distribution is used. Set higher and the distribution becomes closer to a true binomial at the cost of speed, makes very little to no difference (&lt;&lt; 1%) for many applications. <br />
<br />
 </li>
</ul>
</li>
<li><code>#define RNG_N_BOUNDARY_POIS_BINOM 100</code>: <code>RNG_N_BOUNDARY_POIS_BINOM</code> can be set between 1-200<ul>
<li>recommended setting is between 100-200, current default is 100. When simulating a binomial distribution, if the total number of trials, <code>n</code>, for the distribution is greater than RNG_N_BOUNDARY_POIS_BINOM, the poisson approximation is used; less than RNG_N_BOUNDARY_POIS_BINOM, the binomial distribution is used. The binomial calculation gets numerically unstable for large <code>n</code> &gt;&gt; 200.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="Troubleshooting"></a>
Troubleshooting</h2>
<p>Use the embedded link for all <a href="https://github.com/DL42/ParallelPopGen/issues">bug reporting, feature requests, to do, and discussion.</a> Below is a description of the two kinds of errors to encounter during API use: </p><ul>
<li>API errors will be reported as: <code>function name: description</code>. </li>
<li>CUDA errors will be reported as: <code>error # s file s line # generation # population #</code>, where <code>#</code> = number and <code>s</code> = string.<ul>
<li>If a CUDA error is encountered, set <code>__DEBUG__</code> (<a class="el" href="shared_8cuh_source.html">shared.cuh</a> line 23) to true - the program will run slower, but the error will be guaranteed to be reported with the correct file/line number/etc ... <code>__DEBUG__</code> set to true ensures that the CPU and GPU are always in-sync where normally the CPU is allowed to race ahead of the GPU and thus by the time an error from the GPU is reported, the CPU may be executing a different piece of code. If problem is rectified, make sure to turn <code>__DEBUG__</code> back to false to speed up program execution. A reported generation or population of -1 means that generation or population was not relevant to the error. <br />
 <br />
</li>
<li>CUDA out-of-memory errors will typically be the result of a simulation/spectrum that is too big for the GPU's onboard memory. For instance, if running a <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> simulation that starts in mutation-selection equilibrium (i.e. <a class="el" href="struct_g_o___fish_1_1allele__trajectories_1_1sim__constants.html#a62137334ca292069cf24f4635ef26e21" title="true: initialize simulation in mutation_selection_equilibrium; false: initialize blank simulation or ...">GO_Fish::allele_trajectories::sim_constants::init_mse</a> <code>= true</code>) and the population size is too big, so that the program fails in function initialize_mse in <a class="el" href="go__fish__impl_8cuh_source.html">go_fish_impl.cuh</a> before the arrays in struct mutations are allocated, try rescaling the simulation as shown in <a class="el" href="index.html#δaδi">δaδi-to-GOFish Parameter Conversion</a> - either temporarily just for generation 0 with a couple of burn-in generations after all the parameters are reset (selection too!) or for the whole simulation. If there are too many mutations, simply lower the number of independent sites in the simulation using <a class="el" href="struct_g_o___fish_1_1allele__trajectories_1_1sim__constants.html#a1bfe24f3cfc8c2b1ca02a7e8f39d78ed" title="number of sites in simulation ">GO_Fish::allele_trajectories::sim_constants::num_sites</a>.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="δaδi"></a>
δaδi-to-GOFish Parameter Conversion</h2>
<p><a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> simulations are discrete time/discrete frequency simulations. That said, the parameters of such a simulation can be translated into the continuous time/continuous frequency paradigm of δaδi. In δaδi, the main parameter is <code>N<sub>ref</sub></code> - the reference population size of the initial population at time 0. Time, theta, selection, migration, and the population sizes of later generations/other populations are all in reference to <code>N<sub>ref</sub></code>. The list below covers the population genetics functions/variable in a <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> simulation, and how to match that to the corresponding δaδi parameter. <a class="el" href="_example2-_da_di-example.html">Example2-DaDi</a> gives a specific instance of an analogous δaδi and <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> simulation with population scaling. </p>
<h3><a class="anchor" id="Inbreeding"></a>
Inbreeding</h3>
<p>Inbreeding functions return a float parameter, <code>F</code>, between 0 (outbred) and 1 (inbred) inclusive - see <a class="el" href="group__in__mut__dom.html">Simulation Models: Inbreeding, Mutation, and Dominance Group</a> for more detail. In δaδi, populations are outbred, <code>F = 0</code>. </p>
<h3><a class="anchor" id="Dominance"></a>
Dominance</h3>
<p>Dominance functions return a float parameter, <code>h</code>, between -inf and +inf - see <a class="el" href="group__in__mut__dom.html">Simulation Models: Inbreeding, Mutation, and Dominance Group</a> for more detail. <code>h<sub>GOFish</sub></code> <code>=</code> <code>h<sub>δaδi</sub></code>. </p>
<h3><a class="anchor" id="Selection"></a>
Selection</h3>
<p>Selection functions return a selection coefficient, which is a float greater than or equal to -1 (lethal) - see <a class="el" href="group__selection.html">Simulation Models: Selection Group</a> for more detail. In δaδi the selection parameter is the effective selection coefficient, <code>gamma</code> <code>=</code> <code>2Ns</code>, where the selection on alleles <code>AA</code>, <code>Aa</code>, <code>aa</code> are <code>1</code>, <code>1+2hs</code>, <code>1+2s</code> and <code>N</code> is the number of individuals. Thus the equivalent <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> selection coefficient is <code>s<sub>GOFish</sub></code> <code>=</code> <code>2*s<sub>δaδi</sub></code>. <a class="el" href="namespace_sim___model.html" title="Namespace of functions for controlling GO_Fish simulations. ">Sim_Model</a>, like δaδi, has constructors in <a class="el" href="group__selection.html">Simulation Models: Selection Group</a> that allow effective selection coefficients to be input into the simulation (e.g. <a class="el" href="struct_sim___model_1_1selection__constant.html" title="functor: models selection coefficient s as a constant across populations and over time ...">Sim_Model::selection_constant</a>). For an outbred population, <code>F = 0</code>, <code>gamma<sub>GOFish</sub></code> <code>=</code> <code>2Ns<sub>GOFish</sub></code> <code>=</code> <code>2*2Ns<sub>δaδi</sub></code> <code>=</code> <code>2*gamma<sub>δaδi</sub></code>. Effective selection coefficients are invariant to population scaling - see <a class="el" href="index.html#Demography">Demography</a>. </p>
<h3><a class="anchor" id="Demography"></a>
Demography</h3>
<p>Demography functions return a number of individuals, an integer between 0 and max 2<sup>32</sup>-1 inclusive - see <a class="el" href="group__demography.html">Simulation Models: Demography Group</a> for more detail. Like in δaδi, population sizes in simulations can be scaled - doing so requires re-scaling migration rates, the number of generations, and the mutation rate. If taking samples of the populations, it is best to choose a reference population size for the initial population, <code>N<sub>ref_GOFish</sub></code>, such that the size(s) of the sampled population(s) are &gt;&gt; than the sample size, so that using the binomial is an appropriate choice of sampling distribution. </p>
<h3><a class="anchor" id="Migration"></a>
Migration</h3>
<p>Migration functions return a float, <code>m</code>, between 0 and 1 inclusive - see <a class="el" href="group__migration.html">Simulation Models: Migration Group</a> for more detail. Both δaδi and <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> use a conservative model of migration. In δaδi, the migration rate is scaled by the population size, so <code>m<sub>GOFish</sub></code> <code>=</code> <code>m<sub>δaδi</sub><code>/</code>(2N<sub>ref_GOFish</sub></code>), where <code>N<sub>ref_GOFish</sub></code> is the number of initial individuals in the reference population of the <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> simulation. This automatically scales migration rates for different reference population sizes. </p>
<h3><a class="anchor" id="generations"></a>
Number of Generations</h3>
<p>The number of generations in the simulation is a constant integer between 0 and max 2<sup>32</sup>-1 inclusive - use <a class="el" href="struct_g_o___fish_1_1allele__trajectories_1_1sim__constants.html#a24c743e3051a7c443742436154e545b0">GO_Fish::allele_trajectories::sim_constants::num_generations</a> to set the number of generations for a simulation. In δaδi, time <code>T</code> is measured in units of <code>2N<sub>ref</sub></code>, so the corresponding number of generations in <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> would be <code>T*2N<sub>ref_GOFish</sub></code>. Thus, the number of generations in a simulation can be scaled by the population size. Similarly in δaδi Integration.py, one can set the variable <code>dadi.Integration.set_timescale_factor</code> <code>=</code> <code>#</code> where <code>#</code> <code>=</code> <code>1<code>/</code>(num_generations</code>) so that a time step in the integration routine is equal to a discrete generation in the simulation. </p>
<h3><a class="anchor" id="mut_sites"></a>
Mutation rate</h3>
<p>Mutation functions return a per-site, per-generation mutation rate, which a float parameter greater than 0 - see <a class="el" href="group__in__mut__dom.html">Simulation Models: Inbreeding, Mutation, and Dominance Group</a> for more detail. If the simulation population sizes (<code>N<sub>ref_GOFish</sub></code>) have been scaled relative to the actual population sizes <code>N</code>, then, to maintain the same polymorphism level (theta), set <code>mu<sub>ref</sub></code> = <code>mu<sub>actual</sub>*N<code>/N<sub>ref_GOFish</sub></code>.</code> In δaδi, <code>theta<sub>ref</sub></code>, defined as <code>4N<sub>ref</sub>mu</code>, is often (not always) defined to be 1 for the diffusion calculations, then later fit to the data. <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> does not actually use theta as a relevant parameter in the simulations, but the fitted δaδi mutation rates should be equivalent to the pre-scaled <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> <code>mu<sub>actual</sub></code>. </p>
<h3><a class="anchor" id="numSites"></a>
Number of Sites</h3>
<p>The number of sites in the simulation is a constant float between 0 and +inf - use <a class="el" href="struct_g_o___fish_1_1allele__trajectories_1_1sim__constants.html#a1bfe24f3cfc8c2b1ca02a7e8f39d78ed">GO_Fish::allele_trajectories::sim_constants::num_sites</a> to set the number of independent sites for a simulation. While δaδi doesn't have this parameter, grid_size is <em>somewhat</em> analogous in that the more sites there are in a <a class="el" href="namespace_g_o___fish.html" title="Namespace for single locus, forward, Monte-Carlo Wright-Fisher simulation and output data structures...">GO_Fish</a> simulation, then the less noise, the more precise the output of the simulation will be - similarly, the finer the grid size in δaδi, then the more accurate, the more precise the integration. Other than being parameters of precision in their respective tools, they are otherwise quite different in intent. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
